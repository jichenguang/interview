<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="分布式一致性和共识协议"><meta property="og:title" content="分布式一致性和共识协议" />
<meta property="og:description" content="一致性 在分布式系统中，一致性(Consistency，早期也叫 Agreement)是指对于系统中的多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得它们对处理结果达成某种程度的一致。
 一致性并不代表结果正确与否，而是系统对外呈现的状态一致与否，例如，所有节点都达成失败状态也是一种一致。
 分布式的挑战 在实际的计算机集群系统（看似强大的计算机系统，很多地方都比人类世界要脆弱的多）中，存在如下的问题：
 节点之间的网络通讯是不可靠的，包括任意延迟和内容故障； 节点的处理可能是错误的，甚至节点自身随时可能宕机； 同步调用会让系统变得不具备可扩展性。  要解决这些挑战，愿意动脑筋的读者可能会很快想出一些不错的思路。为了简化理解，仍然以两个电影院一起卖票的例子。可能有如下的解决思路：
 每次要卖一张票前打电话给另外一家电影院，确认下当前票数并没超售； 两家电影院提前约好，奇数小时内一家可以卖票，偶数小时内另外一家可以卖； 成立一个第三方的存票机构，票都放到他那里，每次卖票找他询问；  这些思路大致都是可行的。实际上，这些方法背后的思想，将可能引发不一致的并行操作进行串行化，就是现在计算机系统里处理分布式一致性问题的基础思路和唯一秘诀。只是因为计算机系统比较傻，需要考虑得更全面一些；而人们又希望计算机系统能工作的更快更稳定，所以算法需要设计得再精巧一些。
规范的说，理想的分布式系统一致性应该满足：
 可终止性（Termination）：一致的结果在有限时间内能完成； 共识性（Consensus）：不同节点最终完成决策的结果应该相同； 合法性（Validity）：决策的结果必须是其它进程提出的提案。  第一点很容易理解，这是计算机系统可以被使用的前提。需要注意，在现实生活中这点并不是总能得到保障的，例如取款机有时候会是 服务中断 状态，电话有时候是 无法连通 的。
第二点看似容易，但是隐藏了一些潜在信息。算法考虑的是任意的情形，凡事一旦推广到任意情形，就往往有一些惊人的结果。例如现在就剩一张票了，中关村和西单的电影院也分别刚确认过这张票的存在，然后两个电影院同时来了一个顾客要买票，从各自观察看来，自己的顾客都是第一个到的……怎么能达成结果的共识呢？记住我们的唯一秘诀：核心在于需要把两件事情进行排序，而且这个顺序还得是大家都认可的。
第三点看似绕口，但是其实比较容易理解，即达成的结果必须是节点执行操作的结果。仍以卖票为例，如果两个影院各自卖出去一千张，那么达成的结果就是还剩八千张，决不能认为票售光了。
带约束的一致性 绝对理想的 强一致性（Strong Consistency） 代价很大。除非不发生任何故障，所有节点之间的通信无需任何时间，这个时候其实就等价于一台机器了。实际上，越强的一致性要求往往意味着越弱的性能、越低的可用性。
强一致的系统往往比较难实现。很多时候，人们发现实际需求并没有那么强，可以适当放宽一致性要求，降低系统实现的难度。例如在一定约束下实现所谓 最终一致性（Eventual Consistency），即总会存在一个时刻（而不是立刻），系统达到一致的状态，这对于大部分的 Web 系统来说已经足够了。这一类弱化的一致性，被笼统称为 弱一致性（Weak Consistency）。
 我们常见的 异步复制的主从架构实现的是最终一致性 。它的一个典型常见是用户读取异步从库时，可能读取到较旧的信息，因为该从库尚未完全与主库同步。注意，同步复制的主从架构会出现任一节点宕机导致的单点问题。
 共识算法 共识算法解决的是对某个提案（Proposal），大家达成一致意见的过程。提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是领导……等等，可以认为任何需要达成一致的信息都是一个提案。
 实践中，一致性的结果往往还需要客户端的特殊支持，典型地通过访问足够多个服务节点来验证确保获取共识后结果。
 拜占庭问题 拜占庭将军问题描述了一个如下的场景，有一组将军分别指挥一部分军队，每一个将军都不知道其它将军是否是可靠的，也不知道其他将军传递的信息是否可靠，但是它们需要通过投票选择是否要进攻或者撤退。
在这时，无论将军是否可靠，只要所有的将军达成了统一的方案，选择进攻或者撤退其实就是没有任何问题的。上述的情况不会对当前的战局有太多的影响，也不会造成损失，但是如果其中的一个将军告诉其中一部分将军选择进攻、另一部分选择撤退，就会出现非常严重的问题了。
由于将军的队伍中出了一个叛徒或者信息在传递的过程中被拦截，会导致一部分将军会选择进攻，剩下的一部分会选择撤退，它们都认为自己的选择是大多数人的选择，这时就出现了严重的不一致问题。
拜占庭将军问题是对分布式系统容错的最高要求，然而这不是日常工作中使用的大多数分布式系统中会面对的问题，我们遇到更多的还是节点故障宕机或者不响应等情况，这就大大简化了系统对容错的要求。
问题挑战 实际上，如果分布式系统中各个节点都能保证以十分强大的性能（瞬间响应、高吞吐）无故障的运行，则实现共识过程并不复杂，简单通过多播过程投票即可。
很可惜的是，现实中这样完美的系统并不存在，如响应请求往往存在时延、网络会发生中断、节点会发生故障、甚至存在恶意节点故意要破坏系统。
一般地，把故障（不响应）的情况称为 非拜占庭错误 ，恶意响应的情况称为 拜占庭错误（对应节点为拜占庭节点）。
常见算法 针对非拜占庭错误的情况，一般包括 Paxos、Raft 及其变种。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hadyang.github.io/interview/docs/architecture/distributed/consensus/" />
<meta property="article:published_time" content="2020-01-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-01-16T00:00:00+00:00" />
<title>分布式一致性和共识协议 | Interview</title>
<link rel="icon" href="/interview/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/interview/book.min.327a7346ed65bd45e7889adff447f01f212a1b54dbf3c12139d26b63b077108f.css" integrity="sha256-MnpzRu1lvUXniJrf9EfwHyEqG1Tb88EhOdJrY7B3EI8=">


<script defer src="/interview/en.search.min.87fda04675d09933d644da614828f465b615e01603e6c5d96b4efbc54bfc39b2.js" integrity="sha256-h/2gRnXQmTPWRNphSCj0ZbYV4BYD5sXZa077xUv8ObI="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="toc-control" />
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container">
    
  

  <aside class="book-toc levels-3 fixed">
    
    <label id="toc-control" for="toc-control">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一致性">一致性</a>
      <ul>
        <li><a href="#分布式的挑战">分布式的挑战</a></li>
        <li><a href="#带约束的一致性">带约束的一致性</a></li>
      </ul>
    </li>
    <li><a href="#共识算法">共识算法</a>
      <ul>
        <li><a href="#拜占庭问题">拜占庭问题</a></li>
        <li><a href="#问题挑战">问题挑战</a></li>
        <li><a href="#常见算法">常见算法</a></li>
        <li><a href="#理论界限">理论界限</a></li>
        <li><a href="#flp">FLP</a></li>
      </ul>
    </li>
    <li><a href="#一致性consistency与共识consensus">一致性（Consistency）与共识（Consensus）</a></li>
    <li><a href="#cap">CAP</a>
      <ul>
        <li><a href="#弱化一致性">弱化一致性</a></li>
        <li><a href="#弱化可用性">弱化可用性</a></li>
        <li><a href="#弱化分区容忍性">弱化分区容忍性</a></li>
      </ul>
    </li>
    <li><a href="#paxos">Paxos</a>
      <ul>
        <li><a href="#basic-paxos">Basic Paxos</a></li>
        <li><a href="#multi-paxos">Multi-Paxos</a></li>
      </ul>
    </li>
    <li><a href="#raft">Raft</a>
      <ul>
        <li><a href="#leader-election">Leader election</a></li>
        <li><a href="#log-replication">Log Replication</a></li>
        <li><a href="#safety">Safety</a></li>
        <li><a href="#log-compaction">Log Compaction</a></li>
      </ul>
    </li>
    <li><a href="#pow">POW</a></li>
    <li><a href="#可靠性指标">可靠性指标</a></li>
    <li><a href="#参考链接">参考链接</a></li>
  </ul>
</nav>
    </label>
    
  </aside>




    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label id="menu-control" for="menu-control">
    <img src="/interview/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>
  <label id="toc-control" for="toc-control">
  <strong>分布式一致性和共识协议</strong>
  </label>
</header>

      
<article class="markdown"><h2 id="一致性">一致性</h2>
<p>在分布式系统中，一致性(Consistency，早期也叫 Agreement)是指对于系统中的多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得它们对处理结果达成某种程度的一致。</p>
<blockquote>
<p>一致性并不代表结果正确与否，而是系统对外呈现的状态一致与否，例如，所有节点都达成失败状态也是一种一致。</p>
</blockquote>
<h3 id="分布式的挑战">分布式的挑战</h3>
<p>在实际的计算机集群系统（看似强大的计算机系统，很多地方都比人类世界要脆弱的多）中，存在如下的问题：</p>
<ol>
<li>节点之间的网络通讯是不可靠的，包括任意延迟和内容故障；</li>
<li>节点的处理可能是错误的，甚至节点自身随时可能宕机；</li>
<li>同步调用会让系统变得不具备可扩展性。</li>
</ol>
<p>要解决这些挑战，愿意动脑筋的读者可能会很快想出一些不错的思路。为了简化理解，仍然以两个电影院一起卖票的例子。可能有如下的解决思路：</p>
<ol>
<li>每次要卖一张票前打电话给另外一家电影院，确认下当前票数并没超售；</li>
<li>两家电影院提前约好，奇数小时内一家可以卖票，偶数小时内另外一家可以卖；</li>
<li>成立一个第三方的存票机构，票都放到他那里，每次卖票找他询问；</li>
</ol>
<p>这些思路大致都是可行的。实际上，这些方法背后的思想，<strong>将可能引发不一致的并行操作进行串行化</strong>，就是现在计算机系统里处理分布式一致性问题的基础思路和唯一秘诀。只是因为计算机系统比较傻，需要考虑得更全面一些；而人们又希望计算机系统能工作的更快更稳定，所以算法需要设计得再精巧一些。</p>
<p>规范的说，理想的分布式系统一致性应该满足：</p>
<ol>
<li>可终止性（Termination）：一致的结果在有限时间内能完成；</li>
<li>共识性（Consensus）：不同节点最终完成决策的结果应该相同；</li>
<li>合法性（Validity）：决策的结果必须是其它进程提出的提案。</li>
</ol>
<p>第一点很容易理解，这是计算机系统可以被使用的前提。需要注意，在现实生活中这点并不是总能得到保障的，例如取款机有时候会是 <code>服务中断</code> 状态，电话有时候是 <code>无法连通</code> 的。</p>
<p>第二点看似容易，但是隐藏了一些潜在信息。算法考虑的是任意的情形，凡事一旦推广到任意情形，就往往有一些惊人的结果。例如现在就剩一张票了，中关村和西单的电影院也分别刚确认过这张票的存在，然后两个电影院同时来了一个顾客要买票，从各自观察看来，自己的顾客都是第一个到的……怎么能达成结果的共识呢？记住我们的唯一秘诀：<strong>核心在于需要把两件事情进行排序，而且这个顺序还得是大家都认可的</strong>。</p>
<p>第三点看似绕口，但是其实比较容易理解，即达成的结果必须是节点执行操作的结果。仍以卖票为例，如果两个影院各自卖出去一千张，那么达成的结果就是还剩八千张，决不能认为票售光了。</p>
<h3 id="带约束的一致性">带约束的一致性</h3>
<p>绝对理想的 <strong>强一致性（Strong Consistency）</strong> 代价很大。除非不发生任何故障，所有节点之间的通信无需任何时间，这个时候其实就等价于一台机器了。实际上，越强的一致性要求往往意味着越弱的性能、越低的可用性。</p>
<p>强一致的系统往往比较难实现。很多时候，人们发现实际需求并没有那么强，可以适当放宽一致性要求，降低系统实现的难度。例如在一定约束下实现所谓 <strong>最终一致性（Eventual Consistency）</strong>，即总会存在一个时刻（而不是立刻），系统达到一致的状态，这对于大部分的 Web 系统来说已经足够了。这一类弱化的一致性，被笼统称为 <strong>弱一致性（Weak Consistency）</strong>。</p>
<blockquote>
<p>我们常见的 <strong>异步复制的主从架构实现的是最终一致性</strong> 。它的一个典型常见是用户读取异步从库时，可能读取到较旧的信息，因为该从库尚未完全与主库同步。注意，同步复制的主从架构会出现任一节点宕机导致的单点问题。</p>
</blockquote>
<h2 id="共识算法">共识算法</h2>
<p><strong>共识算法解决的是对某个提案（Proposal），大家达成一致意见的过程</strong>。提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是领导……等等，可以认为任何需要达成一致的信息都是一个提案。</p>
<blockquote>
<p>实践中，一致性的结果往往还需要客户端的特殊支持，典型地通过访问足够多个服务节点来验证确保获取共识后结果。</p>
</blockquote>
<h3 id="拜占庭问题">拜占庭问题</h3>
<p>拜占庭将军问题描述了一个如下的场景，有一组将军分别指挥一部分军队，每一个将军都不知道其它将军是否是可靠的，也不知道其他将军传递的信息是否可靠，但是它们需要通过投票选择是否要进攻或者撤退。</p>
<p>在这时，无论将军是否可靠，只要所有的将军达成了统一的方案，选择进攻或者撤退其实就是没有任何问题的。上述的情况不会对当前的战局有太多的影响，也不会造成损失，但是如果其中的一个将军告诉其中一部分将军选择进攻、另一部分选择撤退，就会出现非常严重的问题了。</p>
<p>由于将军的队伍中出了一个叛徒或者信息在传递的过程中被拦截，会导致一部分将军会选择进攻，剩下的一部分会选择撤退，它们都认为自己的选择是大多数人的选择，这时就出现了严重的不一致问题。</p>
<p><strong>拜占庭将军问题是对分布式系统容错的最高要求</strong>，然而这不是日常工作中使用的大多数分布式系统中会面对的问题，我们遇到更多的还是节点故障宕机或者不响应等情况，这就大大简化了系统对容错的要求。</p>
<h3 id="问题挑战">问题挑战</h3>
<p>实际上，如果分布式系统中各个节点都能保证以十分强大的性能（瞬间响应、高吞吐）无故障的运行，则实现共识过程并不复杂，简单通过多播过程投票即可。</p>
<p>很可惜的是，现实中这样完美的系统并不存在，如响应请求往往存在时延、网络会发生中断、节点会发生故障、甚至存在恶意节点故意要破坏系统。</p>
<p>一般地，把故障（不响应）的情况称为 <code>非拜占庭错误</code> ，恶意响应的情况称为 <code>拜占庭错误</code>（对应节点为拜占庭节点）。</p>
<h3 id="常见算法">常见算法</h3>
<p>针对非拜占庭错误的情况，一般包括 <code>Paxos</code>、<code>Raft</code> 及其变种。</p>
<p>对于要能容忍拜占庭错误的情况，一般包括 <code>PBFT</code> 系列、 <code>PoW</code> 系列算法等。从概率角度，PBFT 系列算法是确定的，一旦达成共识就不可逆转；而 PoW 系列算法则是不确定的，随着时间推移，被推翻的概率越来越小。</p>
<h3 id="理论界限">理论界限</h3>
<p>搞学术的人都喜欢对问题先确定一个界限，那么，这个问题的最坏界限在哪里呢？很不幸，<strong>一般情况下，分布式系统的共识问题无解</strong>。</p>
<p>当节点之间的通信网络自身不可靠情况下，很显然，无法确保实现共识。但好在，一个设计得当的网络可以在大概率上实现可靠的通信。然而，即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题的下限是无解。</p>
<p>这个结论，被称为 <strong>FLP 不可能性</strong> 原理，可以看做分布式领域的“测不准原理”。</p>
<h3 id="flp">FLP</h3>
<p>FLP 不可能定理是分布式系统领域最重要的定理之一，它给出了一个非常重要的结论：<strong>在网络可靠并且存在节点失效的异步模型系统中，不存在一个可以解决一致性问题的确定性算法</strong>。</p>
<p>这个定理其实也就是告诉我们不要浪费时间去为异步分布式系统设计在任意场景上都能够实现共识的算法，异步系统完全没有办法保证能在有限时间内达成一致。理解这一原理的一个不严谨的例子是：</p>
<p>三个人在不同房间，进行投票（投票结果是 0 或者 1）。三个人彼此可以通过电话进行沟通，但经常会有人时不时地睡着。比如某个时候，<code>A</code> 投票 0，<code>B</code> 投票 1，<code>C</code> 收到了两人的投票，然后 <code>C</code> 睡着了。<code>A</code> 和 <code>B</code> 则永远无法在有限时间内获知最终的结果。如果可以重新投票，则类似情形每次在取得结果前发生。</p>
<p>这岂不是意味着研究一致性问题压根没有意义吗？</p>
<p>先别这么悲观，学术界做研究，考虑的是数学和物理意义上最极端的情形，很多时候现实生活要美好的多。Paxos算法的场景比FLP的系统模型还要松散，除了异步通信，Paxos允许消息丢失（通信不健壮），但Paxos却被认为是最牛的一致性算法，其作者 Lamport 也获得2014年的图灵奖，这又是为什么？</p>
<p>其实仔细回忆Paxos论文会发现， <strong>Paxos 中存在活锁，理论上的活锁会导致 Paxos 算法无法满足 Termination 属性，也就不算一个正确的一致性算法</strong>。Lamport 在自己的论文中也提到 <code>FLP结果表明，不存在完全满足一致性的异步算法...</code> ，因此他建议通过 <code>Leader</code> 来代替 Paxos 中的 <code>Proposer</code> ，而 <code>Leader</code> 则通过随机或其他方式来选定（Paxos中假如随机过程会极大降低FLP发生的概率）。也就是说Paxos算法其实也不算理论上完全正确的，只是在工程实现中避免了一些理论上存在的问题。</p>
<blockquote>
<p>科学告诉你什么是不可能的；工程则告诉你，付出一些代价，我可以把它变成可能。</p>
</blockquote>
<h2 id="一致性consistency与共识consensus">一致性（Consistency）与共识（Consensus）</h2>
<p>我们常说的 <strong>一致性（Consistency）</strong> 在分布式系统中指的是 <code>副本（Replication）</code> 问题中对于同一个数据的多个副本，其对外表现的数据一致性，如 <code>线性一致性</code> 、<code>因果一致性</code>、<code>最终一致性</code>等，都是用来描述副本问题中的一致性的。</p>
<p>而 <strong>共识（Consensus）</strong> 则不同，共识问题中所有的节点要最终达成共识，由于最终目标是所有节点都要达成一致，所以根本 <strong>不存在一致性强弱</strong> 之分。</p>
<p>只有当你使用像 <code>Paxos</code> 这样的共识算法作为解决副本问题的核心组件时，才会对外展现出不同的一致性级别。但是，即使是在这样的场景下，讨论一个共识算法的一致性也是不合适的，因为 <strong>整个副本系统最终的一致性并不单单取决于共识算法</strong> ，Client 访问所遵循的规范也会有决定性的作用。比如说：即使副本系统使用 <strong>multi-paxos</strong> 在所有副本服务器上同步了日志序号，但如果 Client 被允许从非 Leader 节点获取数据，则整个副本系统仍然不是强一致的。</p>
<h2 id="cap">CAP</h2>
<p>分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。</p>
<ul>
<li><strong>一致性（Consistency）</strong>：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性；</li>
<li><strong>可用性（Availablity）</strong>：在有限时间内，任何非失败节点都能应答请求；</li>
<li><strong>分区容忍性（Partition）</strong>：网络可能发生分区，即节点之间的通信不可保障。</li>
</ul>
<p>比较直观地理解，当网络可能出现分区时候，系统是无法同时保证一致性和可用性的。要么，节点收到请求后因为没有得到其他人的确认就不应答，要么节点只能应答非一致的结果。</p>
<p>好在大部分时候网络被认为是可靠的，因此系统可以提供一致可靠的服务；当网络不可靠时，系统要么牺牲掉一致性（大部分时候都是如此），要么牺牲掉可用性。</p>
<p>既然 CAP 不可同时满足，则设计系统时候必然要弱化对某个特性的支持。</p>
<h3 id="弱化一致性">弱化一致性</h3>
<p>对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设计。</p>
<h3 id="弱化可用性">弱化可用性</h3>
<p>对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计。Paxos、Raft 等算法，主要处理这种情况。</p>
<h3 id="弱化分区容忍性">弱化分区容忍性</h3>
<p>现实中，网络分区出现概率减小，但较难避免。某些关系型数据库、ZooKeeper 即为此设计。实践中，网络通过双通道等机制增强可靠性，达到高稳定的网络通信。</p>
<h2 id="paxos">Paxos</h2>
<p>Paxos 其实是一类能够解决分布式一致性问题的协议，它能够让分布式网络中的节点在出现错误时仍然保持一致；Leslie Lamport 提出的 Paxos 可以在没有恶意节点的前提下保证系统中节点的一致性，也是第一个被证明完备的共识算法，目前的完备的共识算法包括 Raft 本质上都是 Paxos 的变种。</p>
<h3 id="basic-paxos">Basic Paxos</h3>
<p>Basic Paxos 是 Paxos 中最为基础的协议，每一个 Basic Paxos 的协议实例最终都会选择唯一一个结果；使用 Paxos 作为共识算法的分布式系统中，节点都会有三种身份，分别是 <code>Proposer</code>、<code>Acceptor</code> 和 <code>Learner</code>。</p>
<p>Paxos 的运行过程分为两个阶段，分别是准备阶段（Prepare）和接受阶段（Accept），当 Proposer 接收到来自客户端的请求时，就会进入如下流程：</p>
<p><img src="assists/basic-paxos-phases.png" alt=""></p>
<p>在整个共识算法运行的过程中，Proposer 负责提出提案并向 Acceptor 分别发出两次 RPC 请求，Prepare 和 Accept；Acceptor 会根据其持有的信息 <code>minProposal</code>、<code>acceptedProposal</code> 和 <code>acceptedValue</code> 选择接受或者拒绝当前的提案，当某一个提案被过半数的 Acceptor 接受之后，我们就认为当前提案被整个集群接受了。</p>
<h3 id="multi-paxos">Multi-Paxos</h3>
<p>由于大多数的分布式集群都需要接受一系列的值，如果使用 Basic Paxos 来处理数据流，那么就会导致非常明显的性能损失，而 Multi-Paxos 是前者的加强版，如果集群中的 Leader 是非常稳定的，那么我们往往不需要准备阶段的工作，这样就能够将 RPC 的数量减少一半。</p>
<p><img src="assists/multi-paxos-example.png" alt=""></p>
<p>上述图片中描述的就是稳定阶段 Multi-Paxos 的处理过程，S1 是整个集群的 Leader，当其他的服务器接收到来自客户端的请求时，都会将请求转发给 Leader 进行处理。</p>
<p>当然，Leader 角色的出现自然会带来另一个问题，也就是 Leader 究竟应该如何选举，在 Paxos Made Simple 一文中并没有给出 Multi-Paxos 的具体实现方法和细节，所以不同 Multi-Paxos 的实现上总有各种各样细微的差别。</p>
<h2 id="raft">Raft</h2>
<p>Raft 其实就是 Multi-Paxos 的一个变种，Raft 通过简化 Multi-Paxos 的模型，实现了一种更容易让人理解的共识算法，它们两者都能够对一系列连续的问题达成一致。</p>
<p>Raft 在 Multi-Paxos 的基础之上做了两个限制，首先是 Raft 中追加日志的操作必须是连续的，而 Multi-Paxos 中追加日志的操作是并发的，但是对于节点内部的状态机来说两者都是有序的，第二就是 Raft 对 Leader 选举的条件做了限制，只有拥有最新、最全日志的节点才能够当选 Leader，但是 Multi-Paxos 由于任意节点都可以写日志，所以在选择 Leader 上也没有什么限制，只是在选择 Leader 之后需要将 Leader 中的日志补全。</p>
<p>在 Raft 中，所有 Follower 的日志都是 Leader 的子集，而 Multi-Paxos 中的日志并不会做这个保证，由于 Raft 对日志追加的方式和选举过程进行了限制，所以在实现上会更加容易和简单。</p>
<p>从理论上来讲，<strong>支持并发日志追加的 Paxos 会比 Raft 有更优秀的性能，不过其理解和实现上还是比较复杂的</strong>，很多人都会说 Paxos 是科学，而 Raft 是工程，当作者需要去实现一个共识算法，会选择使用 Raft 和更简洁的实现，避免因为一些边界条件而带来的复杂问题。</p>
<p>Raft协议将一致性协议的核心内容分拆成为几个关键阶段，以简化流程，提高协议的可理解性。</p>
<h3 id="leader-election">Leader election</h3>
<p>Raft协议的每个副本都会处于三种状态之一：</p>
<ul>
<li>Leader：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步至多个其他副本</li>
<li>Follower：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件</li>
<li>Candidate：如果 Follower 副本在一段时间内没有收到 Leader 副本的心跳，则判断 Leader 可能已经故障，此时启动选主过程，此时副本会变成 Candidate 状态，直到选主结束。</li>
</ul>
<p><strong>时间被分为很多连续的随机长度的 term ， term 有唯一的 id，每个 term 最多只有一个 Leader</strong> 。每个 term 一开始就进行选主：</p>
<ol>
<li>Follower 将自己维护的 <code>current_term_id</code> 加 1。</li>
<li>然后将自己的状态转成 <code>Candidate</code></li>
<li>发送 <code>RequestVoteRPC</code> 消息(带上 <code>current_term_id</code> ) 给 其它所有 Server</li>
</ol>
<p>本轮选举成功，当收到了 majority 的投票后，状态切成 Leader ，并且定期给其它的所有 Server 发心跳消息（不带 Log 的 <code>AppendEntriesRPC</code> ）以告诉对方自己是 <code>current_term_id</code> 所标识的 term 的 Leader 。<code>term id</code> 作为<code>Logical clock</code>，在每个 RPC 消息中都会带上，用于<strong>检测过期</strong>的消息。</p>
<ul>
<li>当一个 Server 收到的 RPC 消息中的 <code>rpc_term_id</code> 比本地的 <code>current_term_id</code> 更大时，就更新 <code>current_term_id</code> 为 <code>rpc_term_id</code> ，并且如果当前 state 为 Leader 或者 candidate 时，将自己的状态切成 follower。</li>
<li>当 <code>rpc_term_id</code> 比本地的 <code>current_term_id</code> 更小，则拒绝这个RPC消息。</li>
</ul>
<p>本轮选举失败，则没有任何一个 candidate 收到了 majority 的 vote 时，没有 Leader 被选出。这种情况下，每个 candidate 等待的投票的过程就超时了，接着 candidates 都会将本地的 <code>current_term_id</code> 再加1，再等待 <code>150ms ~ 300ms</code> 之后随机发起 <code>RequestVoteRPC</code> 进行新一轮的 Leader election，以避免再次选主失败。</p>
<h3 id="log-replication">Log Replication</h3>
<p>当 Leader 被选出来后，就可以接受客户端发来的请求了，每个请求包含一条需要被 <code>replicated state machines</code> 执行的命令。 Leader 会把它作为一个 Log Entry append 到日志中，然后给其它的 Server 发 AppendEntriesRPC 请求。当 Leader 确定一个 Log Entry 被 <code>safely replicated</code> 了（大多数副本已经将该命令写入日志当中），就 apply 这条 Log Entry 到状态机中然后返回结果给客户端。如果某个 Follower 宕机了或者运行的很慢，或者网络丢包了，则会一直给这个 Follower 发 AppendEntriesRPC 直到日志一致。</p>
<p>当一条日志是 commited 时，Leader 才可以将它应用到状态机中。Raft 保证一条 commited 的 Log Entry 已经持久化了并且会被所有的节点执行。当一个新的 Leader 被选出来时，它的日志和其它的 Follower 的日志可能不一样，这个时候，就需要一个机制来保证日志的一致性。</p>
<p>因此，需要有一种机制来让 Leader 和 Follower 对 Log 达成一致， Leader 会为每个 Follower 维护一个 <code>nextIndex</code> ，表示 Leader 给各个 Follower 发送的下一条 Log Entry 在 Log 中的 <code>index</code> ，初始化为 Leader 的最后一条 Log Entry 的下一个位置。leader 给 Follower 发送 AppendEntriesRPC 消息，带着 <code>(term_id, nextIndex-1)</code>， <code>term_id</code> 即 <code>nextIndex-1</code> 这个槽位的 Log Entry <code>的term_id</code> ，Follower 接收到 AppendEntriesRPC 后，会从自己的 Log 中找是不是存在这样的 Log Entry，如果不存在，就给 Leader 回复拒绝消息，然后 Leader 则将 <code>nextIndex</code> 减1，再重复，直到 AppendEntriesRPC 消息被接收。</p>
<h3 id="safety">Safety</h3>
<p>Raft 保证被选为新 Leader 的节点拥有所有已提交的 Log Entry。这个保证是在 RequestVoteRPC 阶段做的，candidate 在发送 RequestVoteRPC 时，会带上自己的最后一条日志记录的 <code>term_id,index</code> ，其他节点收到消息时，<strong>如果发现自己的日志比 RPC 请求中携带的更新，拒绝投票</strong>。日志比较的原则是，如果本地的最后一条 Log Entry 的 <code>term id</code> 更大，则更新，如果 <code>term id</code> 一样大，则 index 更大的更大。</p>
<h3 id="log-compaction">Log Compaction</h3>
<p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响 availability 。Raft 采用对整个系统进行 snapshot 来处理， snapshot 之前的日志都可以丢弃。Snapshot 技术在 Chubby 和 ZooKeeper 系统中都有采用。</p>
<p>Raft使用的方案是：<strong>每个副本独立的对自己的系统状态进行 Snapshot ，并且只能对已经提交的日志记录（已经应用到状态机）进行snapshot</strong>。</p>
<h2 id="pow">POW</h2>
<p>无论是 Paxos 还是 Raft 其实都只能解决非拜占庭将军容错的一致性问题，不能够应对分布式网络中出现的极端情况，但是这在传统的分布式系统都不是什么问题，无论是分布式数据库还是消息队列集群，它们内部的节点并不会故意的发送错误信息，在类似系统中，最常见的问题就是节点失去响应或者失效，所以它们在这种前提下是有效可行的，也是充分的。</p>
<p><strong>工作量证明（POW，Proof-of-Work）</strong> 是一个用于阻止拒绝服务攻击和类似垃圾邮件等服务错误问题的协议，它在 1993 年被 Cynthia Dwork 和 Moni Naor 提出，它能够帮助分布式系统达到拜占庭容错。</p>
<p>工作量证明的关键特点就是，分布式系统中的请求服务的节点必须解决一个一般难度但是可行（feasible）的问题，但是验证问题答案的过程对于服务提供者来说却非常容易，也就是一个<strong>不容易解答但是容易验证</strong>的问题。</p>
<p>工作量证明的原理其实非常简单，比特币网络选择的谜题非常好的适应了工作量证明定义中的问题，比较难以寻找同时又易于证明，我们可以简单理解为工作量证明防止错误或者无效请求的原理就是增加客户端请求服务的工作量，而适合难度的谜题又能够保证合法的请求不会受到影响。</p>
<p>由于工作量证明需要消耗大量的算力，同时比特币大约 10min 才会产生一个区块，区块的大小也只有 1MB，仅仅能够包含 3、4000 笔交易，平均下来每秒只能够处理 5~7（个位数）笔交易，所以比特币网络的拥堵状况非常严重。</p>
<h2 id="可靠性指标">可靠性指标</h2>
<p>很多领域一般都喜欢谈服务可靠性，用几个 9 来说事。这几个 9 其实是粗略代表了概率意义上系统能提供服务的可靠性指标，最初是电信领域提出的概念。</p>
<p>下表给出不同指标下，每年允许服务出现不可用时间的参考值。</p>
<table>
<thead>
<tr>
<th align="left">指标</th>
<th align="left">概率可靠性</th>
<th align="left">每年允许不可用时间</th>
<th align="left">典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">一个九</td>
<td align="left">90%</td>
<td align="left">1.2 个月</td>
<td align="left">不可用</td>
</tr>
<tr>
<td align="left">二个九</td>
<td align="left">99%</td>
<td align="left">3.6 天</td>
<td align="left">普通单点</td>
</tr>
<tr>
<td align="left">三个九</td>
<td align="left">99.9%</td>
<td align="left">8.6 小时</td>
<td align="left">普通企业</td>
</tr>
<tr>
<td align="left">四个九</td>
<td align="left">99.99%</td>
<td align="left">51.6 分钟</td>
<td align="left">高可用</td>
</tr>
<tr>
<td align="left">五个九</td>
<td align="left">99.999%</td>
<td align="left">5 分钟</td>
<td align="left">电信级</td>
</tr>
<tr>
<td align="left">六个九</td>
<td align="left">99.9999%</td>
<td align="left">31 秒</td>
<td align="left">极高要求</td>
</tr>
<tr>
<td align="left">七个九</td>
<td align="left">99.99999%</td>
<td align="left">3 秒</td>
<td align="left">N/A</td>
</tr>
<tr>
<td align="left">八个九</td>
<td align="left">99.999999%</td>
<td align="left">0.3 秒</td>
<td align="left">N/A</td>
</tr>
<tr>
<td align="left">九个九</td>
<td align="left">99.9999999%</td>
<td align="left">30 毫秒</td>
<td align="left">N/A</td>
</tr>
</tbody>
</table>
<p>一般来说，单点的服务器系统至少应能满足两个九；普通企业信息系统三个九就肯定足够了（大家可以统计下自己企业内因系统维护每年要停多少时间），系统能达到四个九已经是业界领先水平了（参考 AWS）。电信级的应用一般号称能达到五个九，这已经很厉害了，一年里面最多允许五分钟的服务停用。</p>
<p>那么，该如何提升可靠性呢？有两个思路：一是让系统中的单点变得更可靠；二是消灭单点。然而，依靠单点实现的可靠性毕竟是有限的，要想进一步的提升，那就只好消灭单点，通过主从、多活等模式让多个节点集体完成原先单点的工作。这可以<strong>从概率意义上改善服务的可靠性，也是分布式系统的一个重要用途</strong>。</p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://draveness.me/consensus">分布式一致性与共识算法</a></li>
<li><a href="http://www.calvinneo.com/2017/09/20/distributed-system-consistency-and-consensus/">分布式一致性和分布式共识协议</a></li>
<li><a href="http://bLog.kongfy.com/2016/08/%E8%A2%AB%E8%AF%AF%E7%94%A8%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/">被误用的一致性</a></li>
<li><a href="https://bLog.csdn.net/chen77716/article/details/27963079">FLP Impossibility</a></li>
<li><a href="https://wohugb.github.io/blockchain_guide/distribute_system/problem/">一致性问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27207160">Raft协议详解</a></li>
</ul>
</article>

      <div class="book-footer justify-between">
  

  

  
  <div>
    <a class="flex align-center" href="https://github.com/hadyang/interview/edit/master/content/docs/architecture/distributed/consensus/index.md" target="_blank">
      <img src="/interview/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>
  

</div>


<div class="book-comments">
  


</div>


      
    </div>

    <aside class="book-menu fixed">
      <nav id="BookMenu">
<h2 class="book-brand">
  <a href="https://hadyang.github.io/interview/"><span>Interview</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><a href="/interview/docs/basic/">计算机基础</a>
<ul>
<li><a href="/interview/docs/basic/algo/">算法</a>
<ul>
<li><a href="/interview/docs/basic/algo/tree/">树</a></li>
<li><a href="/interview/docs/basic/algo/hash/">Hash</a></li>
<li><a href="/interview/docs/basic/algo/mst/">最小生成树算法</a></li>
<li><a href="/interview/docs/basic/algo/path/">最短路径算法</a></li>
<li><a href="/interview/docs/basic/algo/kmp/">KMP算法</a></li>
<li><a href="/interview/docs/basic/algo/search/">查找算法</a></li>
<li><a href="/interview/docs/basic/algo/sort/">排序算法</a></li>
<li><a href="/interview/docs/basic/algo/skip_list/">跳跃表</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/os/">操作系统</a>
<ul>
<li><a href="/interview/docs/basic/os/arch/">计算机体系结构</a></li>
<li><a href="/interview/docs/basic/os/concurrency/">并发</a></li>
<li><a href="/interview/docs/basic/os/memory/">内存管理</a></li>
<li><a href="/interview/docs/basic/os/disk/">磁盘与文件</a></li>
<li><a href="/interview/docs/basic/os/linux/">Linux系统</a></li>
<li><a href="/interview/docs/basic/os/interrupt/">中断</a></li>
<li><a href="/interview/docs/basic/os/device/">设备管理</a></li>
<li><a href="/interview/docs/basic/os/io/">I/O</a></li>
<li><a href="/interview/docs/basic/os/questions/">面试题</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/net/">计算机网络</a>
<ul>
<li><a href="/interview/docs/basic/net/protocol/">底层网络协议</a></li>
<li><a href="/interview/docs/basic/net/tcp/">TCP</a></li>
<li><a href="/interview/docs/basic/net/ip/">IP</a></li>
<li><a href="/interview/docs/basic/net/http/">HTTP</a></li>
<li><a href="/interview/docs/basic/net/https/">HTTPS</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/database/">数据库</a>
<ul>
<li><a href="/interview/docs/basic/database/transaction/">事务</a></li>
<li><a href="/interview/docs/basic/database/index/">索引</a></li>
<li><a href="/interview/docs/basic/database/sql/">SQL</a></li>
<li><a href="/interview/docs/basic/database/join/">连接</a></li>
<li><a href="/interview/docs/basic/database/mysql/">MySQL</a></li>
<li><a href="/interview/docs/basic/database/concurrent/">并发控制</a></li>
<li><a href="/interview/docs/basic/database/innodb/">Innodb</a></li>
<li><a href="/interview/docs/basic/database/redis/">Redis</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/cryptology/">密码学</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/">Java</a>
<ul>
<li><a href="/interview/docs/java/oop/">OOP</a></li>
<li><a href="/interview/docs/java/serilaser/">序列化</a></li>
<li><a href="/interview/docs/java/operator/">运算符</a></li>
<li><a href="/interview/docs/java/exception/">异常</a></li>
<li><a href="/interview/docs/java/generics/">泛型</a></li>
<li><a href="/interview/docs/java/object/">Object</a></li>
<li><a href="/interview/docs/java/string-builder/">StringBuilder</a></li>
<li><a href="/interview/docs/java/proxy/">代理</a></li>
<li><a href="/interview/docs/java/annotation/">注解</a></li>
<li><a href="/interview/docs/java/questions/">面试题</a></li>
<li><a href="/interview/docs/java/">集合</a>
<ul>
<li><a href="/interview/docs/java/collection/HashMap/">HashMap</a></li>
<li><a href="/interview/docs/java/collection/Concurrenthashmap/">Concurrenthashmap</a></li>
<li><a href="/interview/docs/java/collection/BlockQueue/">BlockQueue</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/concurrent/">并发</a>
<ul>
<li><a href="/interview/docs/java/concurrent/thread/">线程</a></li>
<li><a href="/interview/docs/java/concurrent/volatile/">Volatile</a></li>
<li><a href="/interview/docs/java/concurrent/synchronized/">Synchronized</a></li>
<li><a href="/interview/docs/java/concurrent/AQS/">AQS</a></li>
<li><a href="/interview/docs/java/concurrent/count-down-latch/">CountDownLatch</a></li>
<li><a href="/interview/docs/java/concurrent/threadlocal/">Threadlocal</a></li>
<li><a href="/interview/docs/java/concurrent/interrupt/">线程中断</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/jvm/">Java 虚拟机</a>
<ul>
<li><a href="/interview/docs/java/jvm/jvm-class-load-init/">类加载</a></li>
<li><a href="/interview/docs/java/jvm/jvm-class-loader/">类加载器</a></li>
<li><a href="/interview/docs/java/jvm/dispatcher/">Java分派机制</a></li>
<li><a href="/interview/docs/java/jvm/jvm-architecture/">虚拟机架构</a></li>
<li><a href="/interview/docs/java/jvm/memory-model/">内存模型</a></li>
<li><a href="/interview/docs/java/jvm/string-constant-pool/">String 常量池</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/gc/">GC</a>
<ul>
<li><a href="/interview/docs/java/gc/jvm-gc/">Java 虚拟机垃圾收集</a></li>
<li><a href="/interview/docs/java/gc/jvm-object-lifecycle/">Java 虚拟机对象生命周期</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/">框架</a>
<ul>
<li><a href="/interview/docs/fromwork/netty/">Netty</a></li>
<li><a href="/interview/docs/fromwork/mybatis/">Mybatis</a>
<ul>
<li><a href="/interview/docs/fromwork/mybatis/question/">面试题</a></li>
<li><a href="/interview/docs/fromwork/mybatis/cache/">缓存</a></li>
<li><a href="/interview/docs/fromwork/mybatis/proxy/">代理</a></li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/spring/">Spring</a>
<ul>
<li><a href="/interview/docs/fromwork/spring/ioc/">IOC</a></li>
<li><a href="/interview/docs/fromwork/spring/design-partten/">设计模式</a></li>
<li><a href="/interview/docs/fromwork/spring/aop/">AOP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/architecture/">系统架构</a>
<ul>
<li><a href="/interview/docs/architecture/base/">基本概念</a></li>
<li><a href="/interview/docs/architecture/concurrent/">高并发</a>
<ul>
<li><a href="/interview/docs/architecture/concurrent/flow-control/">流量控制</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/design/">系统设计</a>
<ul>
<li><a href="/interview/docs/architecture/design/tinyURL/">短链接系统</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/distributed/">分布式</a>
<ul>
<li><a href="/interview/docs/architecture/distributed/consensus/"class=active>分布式一致性与共识算法</a></li>
<li><a href="/interview/docs/architecture/distributed/session/">分布式Session</a></li>
<li><a href="/interview/docs/architecture/distributed/cache/">分布式缓存</a></li>
<li><a href="/interview/docs/architecture/distributed/lock/">分布式锁</a></li>
<li><a href="/interview/docs/architecture/distributed/transaction/">分布式事务</a></li>
<li><a href="/interview/docs/architecture/distributed/mq/">消息队列</a></li>
<li><a href="/interview/docs/architecture/distributed/zk/">Zookeeper</a></li>
<li><a href="/interview/docs/architecture/distributed/kafka/">Kafka</a></li>
<li><a href="/interview/docs/architecture/distributed/rpc/">远程调用</a></li>
<li><a href="/interview/docs/architecture/distributed/dubbo/">Dubbo</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/bigdata/">大数据</a>
<ul>
<li><a href="/interview/docs/architecture/bigdata/hdfs/">HDFS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/offer/">剑指offer</a>
<ul>
<li><a href="/interview/docs/offer/search-a-2d-matrix/">搜索二维矩阵</a></li>
<li><a href="/interview/docs/offer/replay-space/">替换空格</a></li>
<li><a href="/interview/docs/offer/print-link-from-tail/">从尾到头打印链表</a></li>
<li><a href="/interview/docs/offer/reConstructBinaryTree/">重建二叉树</a></li>
<li><a href="/interview/docs/offer/two-stack-fifo/">用两个栈实现一个队列</a></li>
<li><a href="/interview/docs/offer/find-minimum-in-rotated-sorted-array/">旋转数组的最小数字</a></li>
<li><a href="/interview/docs/offer/fibonacci/">斐波纳切数列</a></li>
<li><a href="/interview/docs/offer/number-of-one/">二进制中1的个数</a></li>
<li><a href="/interview/docs/offer/power/">数值的整数次方</a></li>
<li><a href="/interview/docs/offer/printn/">打印最大的 n 位数</a></li>
<li><a href="/interview/docs/offer/O1DeleteNode/">在O(1)的时间复杂度下删除节点</a></li>
<li><a href="/interview/docs/offer/reOrderArray/">调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="/interview/docs/offer/FindKthToTail/">链表中倒数第k个结点</a></li>
<li><a href="/interview/docs/offer/revert-link/">反转链表</a></li>
<li><a href="/interview/docs/offer/merge-sort-link/">合并两个排序的链表</a></li>
<li><a href="/interview/docs/offer/HasSubtree/">树的子结构</a></li>
<li><a href="/interview/docs/offer/mirror-tree/">二叉树的镜像</a></li>
<li><a href="/interview/docs/offer/PrintMatrix/">顺时针打印矩阵</a></li>
<li><a href="/interview/docs/offer/MinStack/">包含min函数的栈</a></li>
<li><a href="/interview/docs/offer/IsPopOrder/">栈的压入、弹出序列</a></li>
<li><a href="/interview/docs/offer/PrintFromTopToBottom/">从上往下打印二叉树</a></li>
<li><a href="/interview/docs/offer/VerifySquenceOfBST/">二叉搜索树的后序遍历序列</a></li>
<li><a href="/interview/docs/offer/FindPath/">二叉树中和为某一值的路径</a></li>
<li><a href="/interview/docs/offer/CloneLink/">复杂链表的复制</a></li>
<li><a href="/interview/docs/offer/BST-Link-Convert/">二叉搜索树与双向链表</a></li>
<li><a href="/interview/docs/offer/Permutation/">字符串的排列</a></li>
<li><a href="/interview/docs/offer/MoreThanHalfNum/">数组中出现次数超过一半的数字</a></li>
<li><a href="/interview/docs/offer/GetLeastNumbers/">最小的K个数</a></li>
<li><a href="/interview/docs/offer/FindGreatestSumOfSubArray/">连续子数组的最大和</a></li>
<li><a href="/interview/docs/offer/NumberOfOneBetweenOneAndN/">从1到n整数中1出现的次数</a></li>
<li><a href="/interview/docs/offer/PrintMinNumber/">把数组排成最小的数</a></li>
<li><a href="/interview/docs/offer/GetUglyNumber/">丑数</a></li>
<li><a href="/interview/docs/offer/FirstNotRepeatingChar/">第一个只出现一次的字符</a></li>
<li><a href="/interview/docs/offer/InversePairs/">数组中的逆序对</a></li>
<li><a href="/interview/docs/offer/FindFirstCommonNode/">两个链表的第一个公共结点</a></li>
<li><a href="/interview/docs/offer/GetNumberOfK/">数字在排序数组中出现的次数</a></li>
<li><a href="/interview/docs/offer/TreeDepth/">二叉树的深度</a></li>
<li><a href="/interview/docs/offer/FindNumsAppearOnce/">数组中只出现一次的数字</a></li>
<li><a href="/interview/docs/offer/FindNumbersWithSum/">和为S的两个数字</a></li>
<li><a href="/interview/docs/offer/FindContinuousSequence/">和为S的连续正数序列</a></li>
<li><a href="/interview/docs/offer/ReverseSentence/">翻转单词顺序列</a></li>
<li><a href="/interview/docs/offer/LeftRotateString/">左旋转字符串</a></li>
<li><a href="/interview/docs/offer/SumOfNDice/">n个骰子的点数</a></li>
<li><a href="/interview/docs/offer/isContinuous/">扑克牌顺子</a></li>
<li><a href="/interview/docs/offer/LastRemaining/">圆圈中最后剩下的数</a></li>
<li><a href="/interview/docs/offer/sum/">求1+2+3+&hellip;+n</a></li>
<li><a href="/interview/docs/offer/Add/">不用加减乘除做加法</a></li>
<li><a href="/interview/docs/offer/Singleton/">单例</a></li>
<li><a href="/interview/docs/offer/Duplicate/">数组中重复的数字</a></li>
<li><a href="/interview/docs/offer/GetNext/">二叉树的下一个结点</a></li>
<li><a href="/interview/docs/offer/hasPath/">矩阵中的路径</a></li>
<li><a href="/interview/docs/offer/MovingCount/">机器人的运动范围</a></li>
<li><a href="/interview/docs/offer/CutRope/">剪绳子</a></li>
<li><a href="/interview/docs/offer/PatternMatch/">正则表达式匹配</a></li>
<li><a href="/interview/docs/offer/IsNumeric/">表示数值的字符串</a></li>
<li><a href="/interview/docs/offer/EntryNodeOfLoop/">链表中环的入口</a></li>
<li><a href="/interview/docs/offer/IsSymmetrical/">对称二叉树</a></li>
<li><a href="/interview/docs/offer/SerializeTree/">序列化二叉树</a></li>
<li><a href="/interview/docs/offer/StreamMid/">数据流中的中位数</a></li>
<li><a href="/interview/docs/offer/NOfNumberSerialize/">数字序列中的某一位的数字</a></li>
<li><a href="/interview/docs/offer/TranslateNumToStr/">把数字翻译成字符串</a></li>
<li><a href="/interview/docs/offer/MaxGift/">礼物的最大价值</a></li>
<li><a href="/interview/docs/offer/LongestNoRepeatSubString/">最长不含重复字符的子字符串</a></li>
<li><a href="/interview/docs/offer/CountOfSortedArray/">在排序数组中查找数字</a></li>
<li><a href="/interview/docs/offer/BSTKthNode/">二叉搜索树的第K大节点</a></li>
<li><a href="/interview/docs/offer/MaxInWindows/">滑动窗口的最大值</a></li>
<li><a href="/interview/docs/offer/MaxProfit/">股票的最大利润</a></li>
</ul>
</li>
<li><a href="/interview/docs/leetcode/">LeetCode</a>
<ul>
<li><a href="/interview/docs/leetcode/lengthOfLongestSubstring/">* 无重复字符的最长子串</a></li>
<li><a href="/interview/docs/leetcode/longestCommonPrefix/">最长公共前缀</a></li>
<li><a href="/interview/docs/leetcode/checkInclusion/">字符串的排列</a></li>
<li><a href="/interview/docs/leetcode/StringMultiply/">字符串相乘</a></li>
<li><a href="/interview/docs/leetcode/reverseWords/">翻转字符串里的单词</a></li>
<li><a href="/interview/docs/leetcode/simplifyPath/">* 简化路径</a></li>
<li><a href="/interview/docs/leetcode/restoreIpAddresses/">* 复原IP地址</a></li>
<li><a href="/interview/docs/leetcode/threeSum/">* 三数之和</a></li>
<li><a href="/interview/docs/leetcode/maxAreaOfIsland/">* 岛屿的最大面积</a></li>
<li><a href="/interview/docs/leetcode/searchRote/">* 搜索旋转排序数组</a></li>
<li><a href="/interview/docs/leetcode/findLengthOfLCIS/">最长连续递增序列</a></li>
<li><a href="/interview/docs/leetcode/findKthLargest/">数组中的第K个最大元素</a></li>
<li><a href="/interview/docs/leetcode/longestConsecutive/">最长连续序列</a></li>
<li><a href="/interview/docs/leetcode/findCircleNum/">* 朋友圈</a></li>
<li><a href="/interview/docs/leetcode/mergeRagen/">合并区间</a></li>
<li><a href="/interview/docs/leetcode/trap/">* 接雨水</a></li>
<li><a href="/interview/docs/leetcode/mergeTwoLists/">合并两个有序链表</a></li>
<li><a href="/interview/docs/leetcode/reverseList/">* 反转链表</a></li>
<li><a href="/interview/docs/leetcode/addTwoNumbers/">* 两数相加</a></li>
<li><a href="/interview/docs/leetcode/sortList/">* 排序链表</a></li>
<li><a href="/interview/docs/leetcode/detectCycle/">环形链表 II</a></li>
<li><a href="/interview/docs/leetcode/getIntersectionNode/">相交链表</a></li>
<li><a href="/interview/docs/leetcode/mergeKLists/">* 合并K个排序链表</a></li>
<li><a href="/interview/docs/leetcode/lowestCommonAncestor/">二叉树的最近公共祖先</a></li>
<li><a href="/interview/docs/leetcode/zigzagLevelOrder/">二叉树的锯齿形层次遍历</a></li>
<li><a href="/interview/docs/leetcode/maxProfit/">* 买卖股票的最佳时机</a></li>
<li><a href="/interview/docs/leetcode/maxProfit2/">* 买卖股票的最佳时机 II</a></li>
<li><a href="/interview/docs/leetcode/maxSubArray/">最大子序和</a></li>
<li><a href="/interview/docs/leetcode/MinStack/">* 最小栈</a></li>
<li><a href="/interview/docs/leetcode/LRUCache/">* LRU缓存机制</a></li>
<li><a href="/interview/docs/leetcode/AllOne/">全 O(1) 的数据结构</a></li>
<li><a href="/interview/docs/leetcode/mySqrt/">* x 的平方根</a></li>
<li><a href="/interview/docs/leetcode/validUtf8/">* UTF-8 编码验证</a></li>
<li><a href="/interview/docs/leetcode/salary/">* 第二高的薪水</a></li>
</ul>
</li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>
  </main>

  
</body>

</html>
